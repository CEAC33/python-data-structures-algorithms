# python-data-structures-algorithms-interview

## Overview

**Resources**

- https://nbviewer.jupyter.org/github/jmportilla/Python-for-Algorithms--Data-Structures--and-Interviews/tree/master/




**Non Technical Sections**
- Company and Job Types
- Resume Preparation
- Online Presence
- Networking
- Job Searching
- Non-Technical Interview Questions & Answers
- Post-Interview Topics

**Technical Sections**
* Technical Material Installation Guide
* Algorithms & Data Structures (Theory + Practice Interview Problems)
  - Algorithm Analysis and Big-O Notation
  - Array Sequences
  - Stacks, Queues, and Deques
  - Linked Lists
  - Recursion
  - Trees
  - Searching and Sorting
  - Graphs
  - Riddles

**Mock Interview Sections**
- E-Commerce Company
- Large Search Engine Company
- Ride Share Company
- Social Network Company

## Company and Job Types

### Company Types Overview

**Company Types**
- Big "4"
- Medium Size Companies
- Startups
  - 1-15 Employees
  - Well-Funded "Startups"
  
**Big "4"**
- Several Companies
  - Microsoft
  - Facebook
  - Amazon
  - Apple
  - Google/Alphabet
- Culture varies greatly between all of them
- Check out Glassdoor reviews for specific information on each of them
- They recruit heavily from the top 5-10 Universities (U.S. News. Rankings)
- Management structure in place
- On boarding process
- Decisions at the company level take share-holders into account
- Huge amount of applicants

**Medium Size Companies**
- Local companies
  - May have satellite offices
- May be a stronger focus on profitability
- Management structure can possibly be more informal
  - Try to ask about this during your interview
  
**Start-ups (Small)**
- Lower Salaries but higher equity
- Keep in mind high probability of failure (~90%)
- Equity can be complicated, check out:
  - http://stockoptioncounsel.com/
- You will learn a lot
- You will also work a lot
- People are key at this stage

**Well-funded Startups**
- Salaries can be comparable to Big 4
- Equity at this stage is even more complicated
- For a good list of companies at this stage
  - https://breakoutlist.com/
- Keep in mind funding doesn't guarantee success

**Conclusion**
- Always research the companies beforehand
- Think about work/life balance and what your long term career goals are

### Job Type Overviews

**Job Types**
- Infrastructure
- Backend
- Frontend
- Native
- Science and Theory
- Marketing
- Hardware and Graphics

**Infrastructure**
- Sysadmin (managing, setting up, and keeping systems running)
- Dev-ops (creating & using tools that devs use to manage systems)
- Network Engineer (setting up, designing, and optimizing network infrastructures, TCP/IP, and other layers of the network stack)
- Data Center Ops (they keep "the cloud" running)
- Cable & Router Technicians
- Database Administrators
- Technical Support & Documentation

**Backend**
- Full stack engineers (a little bit of everything)
- Backend Application Development (rails, django, node, etc.)
- Project Management (not always a technical role)
- Engineering Management (usually former developers)
- Software Architects (planning out features before they are coded)
- API Design (designing the interfaces between systems)
- Security & Pentesting
- Distributed System Architects (dealing with consistency, availability, partition tolerance, timing, of large, globally-separated systems)
- Database Administrators (managing, maintaining, sharding, and migrating data stores, different from infrastructure-focused DBAs in that they are also writing backend code which interacts with the stores)

**Frontend**
- Full Stack (a little bit of everything, but focused primarily on the pieces that support a frontend)
- UX/UI Front end designers (photoshop, indesign, sketch, html & css, etc. only)
- General front end web development (html, css, and js)
- Single-page app development (mostly with JS frameworks, e.g. angular or react)
- Quality Assurance & Testing (writing tests, doing human tests, making sure things work)
- iOS, Android, Windows Mobile, etc.
- Consumer-facing Windows Desktop, OS X Desktop, Linux app development
- Enterprise software development (large, made-to-order applications for businesses)
- IT administration & admin software design (often very system-specific, hence the Native category)
- Software Architecture (similar to backend architecture, designing features before they are coded)

**Science and Theory**
- Scientific Research (Matlab, R, and ipython and more)
- "Pure Compsci/Pure Math" Research (with haskell, lisp, lots more)
- Scientific Software Development (e.g. protein folding software)
- Data Science (matlab, r, ipython, scikit-learn, etc.)
- Machine Learning
- OS Design (not just microsoft, windows, & linux, also qualcomm and lots of other telecoms hire tens of thousands of engineers to write embedded and mobile OSs)

**Marketing**
- Growth hacking/web scraping (selenium, beautifulsoup, phantomjs, scikit-learn, pattern, etc.)
- Analytics (GA, mixpanel, optimizely, etc. closely tied with marketing and SEO)
- SEO & SEM (techniques for search engines)
- General Marketing Development (salesforce, analytics, content-design, and SEO)

**Hardware and Graphics**
- Embedded Software (code that runs very close to the metal, e.g. the assembly code running your elevator)
- Chip Design & Architecture
- Game development
- Graphics software development
- 3D printing and machining coding
- CGI & Animation

## Resume Preparation

**1) One Page Resume**
Recruiters *do not* reead your resume;they do a 15-30 second "spot check"of your resume. When your resume is too long, it just takes your best stuff - the stuff that would have made the "one page cut" - and dilutes it with more mediocre content. Lengthy resumes *do not* make you more impressive. A good rule of thumb is to keep your resume to one page if you have less than 10 years of experience or *at most* two pages if you have more than 10 years of experience.

**2) No Objectives**
All on objective does is state, in a wordy way, what position you're interested in. The company already knows that because you applied for a particular position. At best, it'll just waste space. At worst, it'll limit you since it'll exclude other positions that might have been interesting to you

**3) Use a Resume Template with Columns**
Unless you're great with design, you probably shouldn't be creating your own resume template. It'll most likely look sloppy. Use a template, and make sure it has multiple columns. Using three columns, for example, will allow you to put the company name, position, and date all on one line. This makes it easier to read and saves space

**4) Use Tables**
If you're using Microsoft Word to create your resume (which probably should), use Microsoft Word's "tables". Just make sure to hide the borders afterwards

**5) Short Bullets**
Because resume screeners only spend 15-30 seconds on your resume, length bullets - anything that feels like a paragraph - just won't get read. Keep your bullets to one to two lines (with one line being better than two)

**6) Accomplishment Oriented**
Your bullets should focus on your *accomplishments* - that is, the impact you had - rather than your responsibilities. What did you build, create, design, optimize, lead, etc?

**7) Quantify**
Whenever possible, you should quantify your accomplishments. If you optimized something, by how much? If you won an award, out of how many people?

**8) Resume**
The general rule of thumb is to list your GPA if it's at least 3.0 or higher, but there are two important rules to know here: (1) You may choose to list your in-major GPA if it's higher than your overall GPA, but you need to specify that it's your in-major GPA. (2) If your school uses a different scale (such as a 10-point scale), you want to convert your GPA to a 4.0-scale which will be more widely understood

**9) Projects**
Most candidates should pick their top 3-5 projectsto list on their resume. These can be academic required project or independent projects. They *do not* need to be completed or launched either. As long as you've done a "meaty" amount of work on them, that's good enough!

**10) Additional Experience**
You can put additional experience, like leadership activitiees or awards, in a section like this (changing the name of the section depending on what you list).
Be careful here to focus on what really matters.
If you're applying for a coding role, your role as an eagle scout in high school is probably not very important!

**11) Languages and Technologies**
It's a good idea to list your languages and technologies, but remember that anything you list here is "fair game" for the interviewer to test.
If you want to list a language but you happen to be a bit rusty in it, consider listing it as something like: "C++ (Proeficient), C# (Prior Experience), ..."

**12) What did you NOT include?**
Is there anything impressive / interesting that you've done that you left out?
About 50% of candidates leave out an important project or other component of their experience because it wasn't finished / "oficial" / etc. 
If you've done it, and it's impressive enough to "make the cut" (you shouldn't just list *everything* you've ever done), then it belongs on your resume!

### Resume Creation Tools

- https://cvmkr.com/
- https://www.livecareer.com/
- https://www.resume.com/
- https://resumegenius.com/
- https://www.resumebuilder.org/
- https://hipcv.com/
- https://www.visualcv.com/

- https://docs.google.com/document/u/0/?ftv=1&tgif=c#
- https://templates.office.com/en-us/Resumes-and-Cover-Letters

### Resume Checklist

1.- Is the formatting clean, i.e. no weird multi column layouts?

2.- Best resume template: https://quip.com/MFS9AXtq5fk8

3.- Is the resume only 1 page, unless you have 10+ years experience or similar?

4.- Is the resume free of embellishment (or even worse, lies)?

5.- Is it scannable -- can I figure out school/major/roles/companies in 5-10 seconds? Consider bolding or italicizing.

6.- Is it scannable pt 2 -- have you used bullet points wherever possible?

7.- Are you avoiding having multiple different font styles?

8.- Is the alignment/organization/design consistent?

9.- Have you checked over for spelling/grammar?

10.- Current student/recent grads -- do you include major (even if non-CS student), and GPA assuming it is >= 3.1?

11.- For any questions of the form: 'should I include X,' have you asked 'if someone else had X, would it make you want to work with them more so?'

12.- Is the resume in PDF? Have you renamed it to first-last-resume.pdf, or similar? (underscores are fine, but it should include your full name and the word resume)

13.- Do you list your city and state? (And if far from where you are applying, do you note something like 'Open to working in Bay Area')

14.- Have you tailored version of your resumes for companies that are looking for very different things? (e.g. different cities, roles)

15.- Have you removed any info on religion, marital status, and ethnicity?

16.- Can someone identify your graduation year (and starting year of college, too) within 2 seconds?

17.- If you haven't started or been accepted into a MS program yet, are you leaving it off your resume?

18.- Don't include things that aren't relevant

19.- If you went to a non-well known college and are applying to a startup, do you include context on the school (e.g. 4 year university vs 2 year, etc)?

20.- If you transferred or switched schools, do you include a sentence of context as to why?

21.- Have you removed the 'objective' section, if you have one?

22.- Do you include email and phone number?

23.- Do you include Github profile, personal site, and LinkedIn URLs if relevant? And are all the URLs clickable in the PDF?

24.- Have you removed the fluff? e.g. "worked closely with product managers"

25.- Are you avoiding the spammy-looking long list of all the technologies you've worked with? (It's OK to list the ones you are proficient with).

26.- Asking again because it's so common -- do you only list languages/tools that you would be comfortable diving into in an interview?

27.- Projects/experience: do you separate experience notes by projects (most companies divide work into projects)?

28.- Projects/experience: if someone without context on your projects skimmed the bullets, would they a) get it and b) think it is cool/interesting?

29.- Projects/experience: are keywords/acronyms *only* presented in context inside project narratives? Not in lists?

30.- Projects/experience: If possible, can you work in benefits/outcomes into the narrative? (e.g. how you improved performance of Y by 15X, or how you spent 2 months on something that represents 20% of all revenue)?

31.- If possible, find a way to turn it into some kind of number. Numbers generally seem good while scanning.

32.- Seriously, don't underestimate the previous checkbox. Double check it again and try and apply this. The biggest improvements in resumes are always from the previous checkbox. Have you done it even more, for both project and employment bullet points?

33.- For projects: if they were personal projects, do you note as such? Also, if you had partners on the projects, do you note so and note what you specifically did?

34.- Optional tip to make Github better: have you added a really nice looking readme.md for the first project that shows up in your Github account? (See: https://gist.github.com/jxson/1784669)

35.- This is generally as far as someone will go on a quick scan. Click project URL, click Github project URL, scroll through readme.md in 5 seconds, close.

36.- Projects/experience: Within each experience, do you list major accomplishments before minor ones (or even better, delete minor accomplishments)?

37.- Have you applied the advice on benefits to projects, too? (e.g. write number of downloads, users, what people use the project for/why you built it, etc?)

38.- Is your resume ordered such that the best (often, but not always, newest) stuff is first? Education after experience unless it's better (e.g. 4.0 GPA top school vs o-k work experience, then education first)?

39.- If you're a semi recent grad or current student, it's generally still best to put education at the top.

40.- Only if relevant and you need more content: If you are listing courses, are you listing both names and titles, and perhaps some narrative about what you did? One-two vivid descriptions >> a list of 10 courses names.

41.- Do you realize that the resume is just a ticket to an interview?

## Online Presence

### Linkedin

- One of the most important social media platforms for job searching and networking
- It is imperative to have one as you job search!

**What is Linkedin**
- LinkedIn is a business-oriented social networking service
- Most of the site's revenue comes from selling access to information about its users to recruiters and sales professionals

**Linkedin Connections**
- You can use your email contacts to get connections!

**Linkedin Recommendations**
- Start off by asking people you **have worked under or with** to give you recommendations
- Thank them and if possible return the favor by recommending them back
- You can also ask professors and teachers to leave recommendations for your education
- Again, only ask people you personally know!

**Linkedin Skill Endorsements**
- Having scores might give your profile an edge
- Recruiters sometimes keep an eye out for these
- They're actual usefulness is debatable, different people vary their perception of the seriousness of an endorsement

**Linkedin Following**
- You can follow people on Linkedin
- If you produce content (blog posts, articles, new code, etc...) you can post it on Linkedin to your followers!
- They will see it in their feed and get notified
- You can also add a "follow me" button to your personal website

**Linkedin as a Job Search Tool**
- Linkedin has its own job hunting platform!
- Check it out at www.linkedin.com/jobs

**Linkedin Premium**
- Linkedin Premium allows you to InMail people (such as recruiters)
- Allows you to connect with and contact recruiters directly
- Gives you improved information in Linkedin's Job Search tools
- One month free trial

**Discussion Etiquette**
- Please be polite and thoughtful when posting your Linkedin Profile to the discussion boards
- Feel free to post if you genuinely need help, and try to give honest feedback to others
- However don't just spam the boards with your profile!

### GitHub

**GitHub**
- Git is an open source version control software used to track changes in code
- GitHub is a web-based Git repository hosting service
- You can host your code on GitHub for free and keep track of changes to it!
- Need to pay GitHub for private repositories

Guides:
- https://guides.github.com/activities/hello-world/
- https://lab.github.com/

- Make sure to post personal projects that usee code to GitHub!
- Have them presentable with README files!
- Recruiters look at GitHub for potential hires
- GitHub also has its own Job Search tool!

GitHub Jobs:
- https://jobs.github.com/

### Personal Website and Portfolio

**Blog Platforms**
- www.medium.com
- www.wordpress.com
- www.blogger.com

**Website Creation**
If you plan on applying for web development or UI positions, then you should definitely be building your site from scratch (HTML, CSS, JavaScript, etc...)

**Website Creation Services**
- Weebly
- Wix
- SquareSpace

- Many options, google around for more!
- Many provide free versions!

**Domain**
- NameCheap
- Google Domains

**Personal Website**
- Make sure to keep it updated during your job search!
- Not as necessary as a Linkedin, but can definitely improve your standings among other candidates!

## Networking

### Building a Network

**Networking**
- A huge amount of jobs are never publicized!
- Companies hire through the networks of their employees!

- Companies get overwhelmed with applications on their official site

**Building a Network**
- Starting to build a network of contacts can be difficult
- Let's look at some options to build out your network!

**Building a Personal Network**
- Alumni organizations and Classmates
- Children's contacts: PTA, Little League, Scouts, parents of their friends
- Former employers, including supervisors and coworkers
- Friends and Relatives
- Members of clubs: Health club, softball team, hiking club
- Members of your church, temple, synagogue or mosque
- Neighbors: Current and past
- Professionals: Attorneys, accountants, doctors, dentists, insurance agents, pharmacists, veterinarians
- Volunteer associations: Past and present

- Be Proactive
- Give as much as you get
- Take full advantage of the opportunities

### Networking Events

**Conferences**
- Consider going to a conference to meet people in your industry
- Many conferences also have Hiring Fairs
- For example
  - PyCon
  - PyData
  
**MeetUps**
- One of the original sources for networking is www.meetup.com
- Look up programming languages and topics you're interested in!

**Eventful and Eventbrite**
- Not as many "like-minded" group events as MeetUps but has more professional and official events
- May need to buy tickets for those events

## Job Searching

### Organization of Job Search

**Spreadsheets**
- https://drive.google.com/file/d/18i7Dq_yoEpbBY1Cqfv1juKTSSHwKX9T3/view?usp=sharing

**Websites**
- JobHero allows you to track from various sites in browser
- Check it out here:
  - https://gojobhero.com/
  
**Job Funnel**
- So why is it so important to track your job search?
- You will most likely be applying for ~100 jobs
  - (depending on where you live, job availability, experience, etc...)
  
- Job Hunting can also be extremely competitive
- Do not focus exclusively on well-known companies
- There are plenty of great opportunities at companies you haven't heard of

- 100-150 Applications
- 20-30 Responses
- 10-15 Phone Screens
- 5-10 On-Site Interviews
- 2-5 Second On-Site Interviews
- 1-3 Offers

### Job Search Sites

- https://angel.co/jobs
- https://www.glassdoor.com
- https://www.linkedin.com/jobs
- https://www.indeed.com
- https://www.monster.com/
- https://www.dice.com/
- https://stackoverflow.com/jobs
- https://www.androidjobs.io/
- https://www.simplyhired.com/
- https://www.wayup.com/ - Internships

### Company Matching Sites

- https://hired.com/
- https://whitetruffle.com/
- https://www.beseen.com/
- https://underdog.io/ - Startups
- https://triplebyte.com/ - YC Startups
- https://anthology.co/

## During the Interview (Non-Technical)

### 5 Steps of an Interview

**Preparation**
- Get up earlier than usual if you have a morning interview
- Confirm the appointment
- Make sure to bring extre resumes
- Have proper directions and the name of the person you should ask for when you arrive

**Arrival**
- Arrive 10 to 12 minutes before the scheduled appointment
- The moment you arrive consider yourself as making impressions on prospective employers
- Make sure to visit a restroom beforehand
- Be aware of your body language

**Introduction**
- Give a firm handshake with a smile while maintaining eye contact
- Speak with confidence and energy
- Determine the interviewer's communication style and adapt to it

**Communication**
- Make good use of openings
- Prepare for commmon questions
- Communicate your skills, qualifications, and credentials clearly
- Demonstrate your ability to adapt and learn
- Plan, prepare, practice and rehearse!

**Closing**
- Make sure to ask follow up questions
  - Check out list of follow up questions in technical section
- Receive Salary and Compensation packages (after you receive an offer)

### Tough Interview Questions

- Demonstrate your ability to create
- Use real examples from the past
- Show you'll fit in

1.- Tell me about yourself
2.- Why are you leaving your current position?
3.- Why do you want this position?
4.- Where do you see yourself in 5 years?
5.- What is your greatest weakness?
6.- What do you know about our copany?
7.- What's the most difficult situation you had to face at a job?
8.- What do you think makes a successful manager?

### Questions for Students

1.- Why did you choose this profession/major?
2.- What subjects did you enjoy the most and which did you enjoy the least?
3.- What's your greatest achievement in school?

### Special Case Interview Questions

1.- How do you explain the gaps that appear in your resume?
2.- Why has it taken you so long to find work?
3.- Have you ever been fired?
4.- How many positions have you applied for?

## Post Interview

### Salary Negotiations

- Don't bring up salary before the company initiates the conversation
- Always provide a range based off of a minimum
- Understand what you're worth
- Be prepared to support your numbers with evidence

- Don't forget to include benefits as part of the total compensation package
- Don't be too quick to accept a counter offer
- Give yourself room to negotiate

Resources for finding out relevant salary information
- www.salary.com
- www.payscale.com
- www.glassdoor.com

How to Negotiate Your Job Offer - Prof. Deepak Malhotra (Harvard Business School)
- https://www.youtube.com/watch?v=km2Hd_xgo9Q

### Salary Questions and Answers

1.- What kind of salary are you looking for?
2.- What is your current salary?
3.- What would you like to be earning 5 years from now?

### Preparing References

- Identtify 3-5 people to be potential references
  - Usually 3 are required
- Always contact at the beginning of your job search
- Get their email and phone number
- Call your reeferencees letting them know they should expect to be contacted

**Who to ask for a Reference**
- Superiors
  - Promote your value and ability to perform, produce, and contribute to organizational goals
- Peers
  - Endorse your ability to work together as a team member and leader. Confirms your ability to put the organizational agenda before your personal agenda
- Subordinates
  - Vouch for your training and coaching skills. Promoting your supervision skills
- Clients and Vendors
  - Affirm your high-quality customer-service and professional integrity
  
## Algorithm Analysis and Big-O

### Introduction to Algorithm Analysis and Big-O

**Why analyze algorithms?**
- An **algorithm** is simply a procedure or formula for solving a problem
- Some problems are famous enough that the algorithms have names, as well as some procedures being common enough that the algorithm associated with it also has a name

**How do analyze algorithms and how can we compare algorithms against each other?**
- Imagine if you and a friend both came up with functions to sum the numbers to 0 to N
- How would you comparee the functions and algorithms within the functions?

```python
def sum1(n):
  final_sum = 0
  
  for x in range(n+1):
    final_sum += x
    
  return final_sum
```

```python
def sum2(n):
  return (n*(n+1))/2
```

**So how can we objectively compare the algorithms?** 
- We could compare the amount of space they take in memory or we could also compare how much time it takes each function to run. 
- We can use the built in %timeit magic function in jupyter to compare the time of the functions. The %timeit magic in Jupyter Notebooks will repeat the loop iteration a certain number of times and take the best result

```python
%timeit sum1(100)
```

The slowest run took 5.15 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 4.86 µs per loop

```python
%timeit sum2(100)
```

The slowest run took 16.54 times longer than the fastest. This could mean that an intermediate result is being cached 
10000000 loops, best of 3: 173 ns per loop

We can see that the second function is much more efficient! Running at a much faster rate than the first. However, we can not use "time to run" as an objective measurement, because that will depend on the speed of the computer itself and hardware capabilities. So we will need to use another method, **Big-O**!

### Big-O Notation

Big-O notation describes how quickly runtime will grow relative to the input as the input get arbitrarily large.

Let's examine some of these points more closely:

- Remember, we want to compare how quickly runtime will grows, not compare exact runtimes, since those can vary depending on hardware.

- Since we want to compare for a variety of input sizes, we are only concerned with runtime grow relative to the input. This is why we use **n** for notation.

- As n gets arbitrarily large we only worry about terms that will grow the fastest as n gets large, to this point, Big-O analysis is also known as **asymptotic analysis**

As for syntax sum1() can be said to be **O(n)** since its runtime grows linearly with the input size. In the next lecture we will go over more specific examples of various O() types and examples. To conclude this lecture we will show the potential for vast difference in runtimes of Big-O functions.

**Runtimes of Common Big-O Functions**

Here is a table of common Big-O functions:

|Big-O |	Name|
|---|---|
|1|	Constant|
|log(n)|	Logarithmic|
|n|	Linear|
|nlog(n)|	Log Linear|
|n^2|	Quadratic|
|n^3|	Cubic|
|2^n|	Exponential|

Now let's plot the runtime versus the Big-O to compare the runtimes. We'll use a simple matplotlib for the plot below

```python
from math import log
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
plt.style.use('bmh')

# Set up runtime comparisons
n = np.linspace(1,10,1000)
labels = ['Constant','Logarithmic','Linear','Log Linear','Quadratic','Cubic','Exponential']
big_o = [np.ones(n.shape),np.log(n),n,n*np.log(n),n**2,n**3,2**n]

# Plot setup
plt.figure(figsize=(12,10))
plt.ylim(0,50)

for i in range(len(big_o)):
    plt.plot(n,big_o[i],label = labels[i])


plt.legend(loc=0)
plt.ylabel('Relative Runtime')
plt.xlabel('n')
```

### Big-O Examples

In the first part of the Big-O example section we will go through various iterations of the various Big-O functions. Make sure to complete the reading assignment!

Let's begin with some simple examples and explore what their Big-O is.

**O(1) Constant**
```python
def func_constant(values):
    '''
    Prints first item in a list of values.
    '''
    print values[0]
    
func_constant([1,2,3])
```
1

Note how this function is constant because regardless of the list size, the function will only ever take a constant step size, in this case 1, printing the first value from a list. so we can see here that an input list of 100 values will print just 1 item, a list of 10,000 values will print just 1 item, and a list of n values will print just 1 item!

**O(n) Linear**
```python
def func_lin(lst):
    '''
    Takes in list and prints out all values
    '''
    for val in lst:
        print val
        
func_lin([1,2,3])
```
1
2
3

This function runs in O(n) (linear time). This means that the number of operations taking place scales linearly with n, so we can see here that an input list of 100 values will print 100 times, a list of 10,000 values will print 10,000 times, and a list of n values will print n times.

**O(n^2) Quadratic**
```python
def func_quad(lst):
    '''
    Prints pairs for every item in list.
    '''
    for item_1 in lst:
        for item_2 in lst:
            print item_1,item_2
            
lst = [0, 1, 2, 3]

func_quad(lst)
```
0 0
0 1
0 2
0 3
1 0
1 1
1 2
1 3
2 0
2 1
2 2
2 3
3 0
3 1
3 2
3 3

Note how we now have two loops, one nested inside another. This means that for a list of n items, we will have to perform n operations for every item in the list! This means in total, we will perform n times n assignments, or n^2. So a list of 10 items will have 10^2, or 100 operations. You can see how dangerous this can get for very large inputs! This is why Big-O is so important to be aware of!

**Calculating Scale of Big-O**

In this section we will discuss how insignificant terms drop out of Big-O notation.

When it comes to Big O notation we only care about the most significant terms, remember as the input grows larger only the fastest growing terms will matter. If you've taken a calculus class before, this will reminf you of taking limits towards infinity. Let's see an example of how to drop constants:

```python
def print_once(lst):
    '''
    Prints all items once
    '''
    for val in lst:
        print val
print_once(lst)
```
0
1
2
3

The print_once() function is O(n) since it will scale linearly with the input. What about the next example?
```python
def print_3(lst):
    '''
    Prints all items three times
    '''
    for val in lst:
        print val
        
    for val in lst:
        print val
        
    for val in lst:
        print val
print_3(lst)
```
0
1
2
3
0
1
2
3
0
1
2
3

We can see that the first function will print O(n) items and the second will print O(3n) items. However for n going to inifinity the constant can be dropped, since it will not have a large effect, so both functions are O(n).

Let's see a more complex example of this:
```python
def comp(lst):
    '''
    This function prints the first item O(1)
    Then is prints the first 1/2 of the list O(n/2)
    Then prints a string 10 times O(10)
    '''
    print lst[0]
    
    midpoint = len(lst)/2
    
    for val in lst[:midpoint]:
        print val
        
    for x in range(10):
        print 'number'
lst = [1,2,3,4,5,6,7,8,9,10]

comp(lst)
```
1
1
2
3
4
5
number
number
number
number
number
number
number
number
number
number

So let's break down the operations here. We can combine each operation to get the total Big-O of the function:

O(1+n/2+10)

We can see that as n grows larger the 1 and 10 terms become insignificant and the 1/2 term multiplied against n will also not have much of an effect as n goes towards infinity. This means the function is simply O(n)!

**Worst Case vs Best Case**

Many times we are only concerned with the worst possible case of an algorithm, but in an interview setting its important to keep in mind that worst case and best case scenarios may be completely different Big-O times. For example, consider the following function:

```python
def matcher(lst,match):
    '''
    Given a list lst, return a boolean indicating if match item is in the list
    '''
    for item in lst:
        if item == match:
            return True
    return False
```
```
lst
```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
matcher(lst,1)
```
True
```
matcher(lst,11)
```
False

Note that in the first scenario, the best case was actually O(1), since the match was found at the first element. In the case where there is no match, every element must be checked, this results in a worst case time of O(n). Later on we will also discuss average case time.

Finally let's introduce the concept of space complexity.

**Space Complexity**

Many times we are also concerned with how much memory/space an algorithm uses. The notation of space complexity is the same, but instead of checking the time of operations, we check the size of the allocation of memory.

Let's see a few examples:
```python
def printer(n=10):
    '''
    Prints "hello world!" n times
    '''
    for x in range(n):
        print 'Hello World!'
```
```
printer()
```
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!

Note how we only assign the 'hello world!' variable once, not every time we print. So the algorithm has O(1) **space** complexity and an O(n) **time** complexity.

Let's see an example of O(n) **space** complexity:
```python
def create_list(n):
    new_list = []
    
    for num in range(n):
        new_list.append('new')
    
    return new_list
```
```
print create_list(5)
```
['new', 'new', 'new', 'new', 'new']

Note how the size of the new_list object scales with the input n, this shows that it is an O(n) algorithm with regards to space complexity.

### Big-O for Python Data Structures

**Big O for Python Data Structures**

In this lecture we will go over the Big O of built-in data structures in Python: Lists and Dictionaries.

**Lists**

In Python lists act as dynamic arrays and support a number of common operations through methods called on them. The two most common operations performed on a list are indexing and assigning to an index position. These operations are both designed to be run in constant time, O(1).

Let's imagine you wanted to test different methods to construct a list that is [0,1,2...10000]. Let go ahead and compare various methods, such as appending to the end of a list, concatenating a list, or using tools such as casting and list comprehension.

For example:
```python
def method1():
    l = []
    for n in xrange(10000):
        l = l + [n]

def method2():
    l = []
    for n in xrange(10000):
        l.append(n)

def method3():
    l = [n for n in xrange(10000)]

def method4():
    l = range(10000) # Python 3: list(range(10000))
```

Let's now test these methods using the timeit magic function:

```python
%timeit method1()
%timeit method2()
%timeit method3()
%timeit method4()
```

10 loops, best of 3: 162 ms per loop
1000 loops, best of 3: 820 µs per loop
1000 loops, best of 3: 307 µs per loop
10000 loops, best of 3: 77.7 µs per loop

We can clearly see that the most effective method is the built-in range() function in Python!

It is important to keep these factors in mind when writing efficient code. More importantly begin thinking about how we are able to index with O(1). We will discuss this in more detail when we cover arrays general. For now, take a look at the table below for an overview of Big-O efficiencies.

**Table of Big-O for common list operations
Please note, in order to see this table, you may need to download this .ipynb file and view it locally, sometimes GitHub or nbveiwer have trouble showing the HTML for it...**

|**Operation**	|**Big-O Efficiency**|
|--|--|
|index []|	O(1)|
|index assignment|	O(1)|
|append|	O(1)|
|pop()|	O(1)|
|pop(i)|	O(n)|
|insert(i,item)|	O(n)|
|del operator	|O(n)|
|iteration	|O(n)|
|contains (in)|	O(n)|
|get slice [x:y]	|O(k)|
|del slice|	O(n)|
|set slice	|O(n+k)|
|reverse|	O(n)|
|concatenate|	O(k)|
|sort	|O(n log n)|
|multiply|	O(nk)|

**Dictionaries**

Dictionaries in Python are an implementation of a hash table. They operate with keys and values, for example:
```python
d = {'k1':1,'k2':2}
```
```python
d['k1']
```
1

Something that is pretty amazing is that getting and setting items in a dictionary are O(1)! Hash tables are designed with efficiency in mind, and we will explore them in much more detail later on in the course as one of the most important data structures to undestand. In the meantime, refer to the table below for Big-O efficiencies of common dictionary operations:

|**Operation**|	**Big-O Efficiency**|
|--|--|
|copy	|O(n)|
|get item|	O(1)|
|set item|	O(1)|
|delete item	|O(1)|
|contains (in)|	O(1)|
|iteration|	O(n)|
